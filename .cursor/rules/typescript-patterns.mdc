---
description: 
globs: 
alwaysApply: false
---
# TypeScript Patterns & Best Practices

## Project Configuration
This project uses TypeScript with strict type checking. Configuration is in [tsconfig.json](mdc:tsconfig.json).

## Component Typing Patterns

### React Component Types
```tsx
// Functional component with props
interface ButtonProps {
  variant?: "default" | "destructive" | "outline" | "secondary" | "ghost" | "link"
  size?: "default" | "sm" | "lg" | "icon"
  children: React.ReactNode
  onClick?: () => void
  disabled?: boolean
}

export function CustomButton({ 
  variant = "default", 
  size = "default",
  children, 
  onClick,
  disabled = false
}: ButtonProps) {
  return (
    <Button 
      variant={variant} 
      size={size} 
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </Button>
  )
}

// Component with generic types
interface DataListProps<T> {
  items: T[]
  renderItem: (item: T) => React.ReactNode
  keyExtractor: (item: T) => string
}

export function DataList<T>({ items, renderItem, keyExtractor }: DataListProps<T>) {
  return (
    <div className="space-y-4">
      {items.map(item => (
        <div key={keyExtractor(item)}>
          {renderItem(item)}
        </div>
      ))}
    </div>
  )
}
```

### Form and Event Handling
```tsx
// Form event types
interface LoginFormData {
  email: string
  password: string
}

export function LoginForm() {
  const [formData, setFormData] = useState<LoginFormData>({
    email: "",
    password: ""
  })

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    // Handle form submission
  }

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    setFormData(prev => ({
      ...prev,
      [name]: value
    }))
  }

  return (
    <form onSubmit={handleSubmit}>
      <Input
        name="email"
        type="email"
        value={formData.email}
        onChange={handleInputChange}
      />
      <Button type="submit">Login</Button>
    </form>
  )
}
```

## Firebase/Firestore Type Integration

### Firestore Types
```tsx
import { Timestamp } from 'firebase/firestore'
import { User as FirebaseUser } from 'firebase/auth'

// Base document interface
export interface BaseDocument {
  id?: string
  createdAt?: Timestamp | { seconds: number; nanoseconds: number }
  updatedAt?: Timestamp | { seconds: number; nanoseconds: number }
}

// User profile type
export interface UserProfile extends BaseDocument {
  uid: string
  email: string | null
  displayName: string | null
  photoURL: string | null
  emailVerified: boolean
}

// Example domain types
export interface Todo extends BaseDocument {
  title: string
  description?: string
  completed: boolean
  userId: string
}

export interface Post extends BaseDocument {
  title: string
  content: string
  authorId: string
  authorName: string
  published: boolean
  tags: string[]
  likes: number
}

// Collection names enum for type safety
export enum Collections {
  USERS = 'users',
  TODOS = 'todos',
  POSTS = 'posts',
}
```

### Firestore Service Types
```tsx
import { FirestoreService } from '@/lib/firebase/firestore'
import { where, orderBy } from 'firebase/firestore'

// Type-safe Firestore service usage
const todosService = new FirestoreService<Todo>(Collections.TODOS)

// Creating a document
async function createTodo(userId: string, title: string): Promise<string> {
  const todoId = await todosService.create({
    title,
    completed: false,
    userId,
  })
  return todoId
}

// Querying with type safety
async function getUserTodos(userId: string): Promise<Todo[]> {
  const todos = await todosService.getAll([
    where('userId', '==', userId),
    orderBy('createdAt', 'desc')
  ])
  return todos
}

// Real-time subscription with types
function subscribeToTodos(
  userId: string, 
  onUpdate: (todos: Todo[]) => void
): () => void {
  return todosService.subscribe(
    [where('userId', '==', userId)],
    onUpdate,
    (error) => console.error('Todo subscription error:', error)
  )
}
```

### Authentication Types
```tsx
// Auth context type
interface AuthContextType {
  user: FirebaseUser | null
  profile: UserProfile | null
  loading: boolean
  error: string | null
}

// Auth hook return type
interface UseAuthReturn extends AuthContextType {
  signIn: (email: string, password: string) => Promise<AuthResponse>
  signUp: (email: string, password: string, displayName?: string) => Promise<AuthResponse>
  signOut: () => Promise<{ error: string | null }>
  signInWithGoogle: () => Promise<AuthResponse>
}

// Auth response type
interface AuthResponse {
  user?: FirebaseUser
  error?: string | null
}

// Usage in components
export function useAuth(): UseAuthReturn {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}
```

## Hook Patterns

### Custom Hook Types
```tsx
// State management hook
interface UseToggleReturn {
  isToggled: boolean
  toggle: () => void
  setToggled: (value: boolean) => void
}

export function useToggle(initialValue = false): UseToggleReturn {
  const [isToggled, setIsToggled] = useState(initialValue)

  const toggle = useCallback(() => {
    setIsToggled(prev => !prev)
  }, [])

  const setToggled = useCallback((value: boolean) => {
    setIsToggled(value)
  }, [])

  return { isToggled, toggle, setToggled }
}

// Firestore collection hook
interface UseCollectionReturn<T> {
  data: T[]
  loading: boolean
  error: string | null
  refetch: () => Promise<void>
}

export function useCollection<T extends BaseDocument>(
  collectionName: string,
  constraints: QueryConstraint[] = []
): UseCollectionReturn<T> {
  const [data, setData] = useState<T[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Implementation...
  
  return { data, loading, error, refetch }
}
```

## Utility Type Patterns

### Firebase-Specific Utility Types
```tsx
// Extract Firestore document data type
type DocumentData<T> = Omit<T, 'id'>

// Timestamp conversion helper
type WithTimestamps<T> = T & {
  createdAt: Timestamp
  updatedAt: Timestamp
}

// Partial update type for Firestore
type UpdateData<T> = Partial<Omit<T, 'id' | 'createdAt'>>

// Query constraint builder type
type WhereFilter<T> = {
  field: keyof T
  operator: '<' | '<=' | '==' | '>' | '>=' | '!=' | 'array-contains' | 'in' | 'not-in'
  value: any
}

// Server timestamp type for new documents
type WithServerTimestamp<T> = Omit<T, 'createdAt' | 'updatedAt'> & {
  createdAt: ReturnType<typeof serverTimestamp>
  updatedAt: ReturnType<typeof serverTimestamp>
}
```

### Context and Provider Types
```tsx
// Theme context
interface ThemeContextType {
  theme: 'light' | 'dark' | 'system'
  setTheme: (theme: 'light' | 'dark' | 'system') => void
  resolvedTheme: 'light' | 'dark'
}

const ThemeContext = createContext<ThemeContextType | null>(null)

// Firebase context provider props
interface FirebaseProviderProps {
  children: React.ReactNode
  config: {
    apiKey: string
    authDomain: string
    projectId: string
    storageBucket: string
    messagingSenderId: string
    appId: string
  }
}
```

## Error Handling Types

### Firebase Error Types
```tsx
// Firebase error wrapper
interface FirebaseError {
  code: string
  message: string
  name: string
}

// Type guard for Firebase errors
function isFirebaseError(error: unknown): error is FirebaseError {
  return (
    typeof error === 'object' &&
    error !== null &&
    'code' in error &&
    'message' in error
  )
}

// Error handling in async functions
async function handleFirebaseOperation<T>(
  operation: () => Promise<T>
): Promise<{ data?: T; error?: string }> {
  try {
    const data = await operation()
    return { data }
  } catch (error) {
    if (isFirebaseError(error)) {
      return { error: error.message }
    }
    return { error: 'An unexpected error occurred' }
  }
}
```

### Error Boundaries
```tsx
interface ErrorInfo {
  componentStack: string
  errorBoundary?: string
  errorInfo?: string
}

interface ErrorBoundaryState {
  hasError: boolean
  error: Error | null
  errorInfo: ErrorInfo | null
}

class ErrorBoundary extends Component<
  React.PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: React.PropsWithChildren<{}>) {
    super(props)
    this.state = { hasError: false, error: null, errorInfo: null }
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({ errorInfo })
  }

  render() {
    if (this.state.hasError) {
      return (
        <Alert variant="destructive">
          <AlertDescription>
            Something went wrong. Please try again.
          </AlertDescription>
        </Alert>
      )
    }

    return this.props.children
  }
}
```

## Best Practices

### Type Safety Guidelines
- Use strict TypeScript configuration
- Prefer interfaces over types for object shapes
- Use union types for controlled values
- Always type function parameters and return values
- Use generic types for reusable components
- Leverage utility types for transformations
- Use type guards for runtime type checking

### Firebase-Specific Best Practices
- Always type Firestore documents with base interfaces
- Use enums for collection names to avoid typos
- Create type-safe wrapper functions for Firebase operations
- Use discriminated unions for auth states
- Type Firebase configuration objects
- Handle Firebase-specific errors with type guards

### Performance Considerations
- Use `React.memo` with proper prop types
- Type `useCallback` and `useMemo` dependencies
- Use `as const` for readonly arrays and objects
- Prefer branded types for IDs and sensitive data

### Code Organization
- Export types alongside components
- Create shared type definitions in `@/lib/firebase/types`
- Use barrel exports for clean imports
- Group related types together
- Document complex types with JSDoc comments